# [RFC: 793 TRANSMISSION CONTROL PROTOCOL](https://tools.ietf.org/html/rfc793)

- [RFC: 793 TRANSMISSION CONTROL PROTOCOL](#rfc-793-transmission-control-protocol)
  - [1. INTRODUCTION](#1-introduction)
    - [1.1.  Motivation](#11--motivation)
    - [1.2. Scope](#12-scope)
    - [1.3. About this Document](#13-about-this-document)
    - [1.4.  Interfaces](#14--interfaces)
    - [1.5.  Operation](#15--operation)
  - [2. PHILOSOPHY](#2-philosophy)
    - [2.1. Elements of the Internetwork System](#21-elements-of-the-internetwork-system)
    - [2.2.  Model of Operation](#22--model-of-operation)
    - [2.3. The Host Environment](#23-the-host-environment)
    - [2.4. Interfaces](#24-interfaces)
    - [2.5. Relation to Other Protocols](#25-relation-to-other-protocols)
    - [2.6. Reliable Communication](#26-reliable-communication)
    - [2.7. Connection Establishment and Clearing](#27-connection-establishment-and-clearing)
    - [2.8. Data Communication](#28-data-communication)
    - [2.9. Precedence and Security](#29-precedence-and-security)
    - [2.10. Robustness Principle](#210-robustness-principle)
  - [3. FUNCTIONAL SPECIFICATION](#3-functional-specification)
    - [3.1. Header Format](#31-header-format)
    - [3.2. Terminology](#32-terminology)

## 1. INTRODUCTION

The Transmission Control Protocol (TCP) is intended for use as a highly reliable host-to-host protocol between hosts in packet-switched computer communication networks, and in interconnected systems of such networks.

This document describes the functions to be performed by the Transmission Control Protocol, the program that implements it, and its interface to programs or users that require its services.

### 1.1.  Motivation

Computer communication systems are playing an increasingly important role in military, government, and civilian environments.  This document focuses its attention primarily on military computer communication requirements, especially robustness in the presence of communication unreliability and availability in the presence of congestion, but many of these problems are found in the civilian and government sector as well.

As strategic and tactical computer communication networks are developed and deployed, it is essential to provide means of interconnecting them and to provide standard interprocess communication protocols which can support a broad range of
applications. In anticipation of the need for such standards, the Deputy Undersecretary of Defense for Research and Engineering has declared the Transmission Control Protocol (TCP) described herein to be a basis for DoD-wide inter-process communication protocol standardization.

TCP is a **connection-oriented**, **end-to-end reliable protocol** designed to fit into a layered hierarchy of protocols which support multi-network applications. The TCP provides for **reliable inter-process communication** between pairs of processes in host computers attached to distinct but interconnected computer communication networks. Very few assumptions are made as to the reliability of the communication protocols below the TCP layer. TCP assumes it can obtain a simple, potentially unreliable datagram service from the lower level protocols. In principle, the TCP should be able to operate above a wide spectrum of communication systems ranging from hard-wired connections to packet-switched or circuit-switched networks.

TCP is based on concepts first described by Cerf and Kahn in [1].  The TCP fits into a layered protocol architecture just above a basic Internet Protocol [2] which provides a way for the TCP to send and receive variable-length segments of information enclosed in internet datagram "envelopes". The internet datagram provides a means for addressing source and destination TCPs in different networks. The internet protocol also deals with any fragmentation or reassembly of the TCP segments required to achieve transport and delivery through multiple networks and interconnecting gateways. The internet protocol also carries information on the precedence, security classification and compartmentation of the TCP segments, so this information can be communicated end-to-end across multiple networks.

                           Protocol Layering

                        +---------------------+
                        |     higher-level    |
                        +---------------------+
                        |        TCP          |
                        +---------------------+
                        |  internet protocol  |
                        +---------------------+
                        |communication network|
                        +---------------------+

                                Figure 1

Much of this document is written in the context of TCP implementations which are co-resident with higher level protocols in the host computer. Some computer systems will be connected to networks via front-end computers which house the TCP and internet protocol layers, as well as network specific software. The TCP specification describes an interface to the higher level protocols which appears to be implementable even for the front-end case, as long as a suitable host-to-front end protocol is implemented.

### 1.2. Scope

The TCP is intended to provide a reliable process-to-process communication service in a multinetwork environment. The TCP is intended to be a host-to-host protocol in common use in multiple networks.

### 1.3. About this Document

This document represents a specification of the behavior required of any TCP implementation, both in its interactions with higher level protocols and in its interactions with other TCPs. The rest of this section offers a very brief view of the protocol interfaces and operation. Section 2 summarizes the philosophical basis for the TCP design. Section 3 offers both a detailed description of the actions required of TCP when various events occur (arrival of new segments, user calls, errors, etc.) and the details of the formats of TCP segments.

### 1.4.  Interfaces

The TCP interfaces on one side to user or application processes and on the other side to a lower level protocol such as Internet Protocol.

The interface between an application process and the TCP is illustrated in reasonable detail. This interface consists of a set of calls much like the calls an operating system provides to an application process for manipulating files.  For example, there are calls to open and close connections and to send and receive data on established connections.  It is also expected that the TCP can asynchronously communicate with application programs. Although considerable freedom is permitted to TCP implementors to design interfaces which are appropriate to a particular operating system environment, a minimum functionality is required at the TCP/user interface for any valid implementation.

The interface between TCP and lower level protocol is essentially unspecified except that it is assumed there is a mechanism whereby the two levels can asynchronously pass information to each other. Typically, one expects the lower level protocol to specify this interface. TCP is designed to work in a very general environment of interconnected networks. The lower level protocol which is assumed throughout this document is the Internet Protocol [2].

### 1.5.  Operation

As noted above, the primary purpose of the TCP is to provide reliable, securable logical circuit or connection service between pairs of processes. To provide this service on top of a less reliable internet communication system requires facilities in the following areas:

  Basic Data Transfer  
  Reliability  
  Flow Control  
  Multiplexing  
  Connections  
  Precedence and Security  

The basic operation of the TCP in each of these areas is described in the following paragraphs.

- Basic Data Transfer:

  The TCP is able to transfer a continuous stream of octets in each direction between its users by packaging some number of octets into **segments** for transmission through the internet system. In general, the TCPs decide **when to block and forward data** at their own convenience.

  Sometimes users need to be sure that all the data they have submitted to the TCP has been transmitted. For this purpose a **push function** is defined. To assure that data submitted to a TCP is actually transmitted the sending user indicates that it should be pushed through to the receiving user. A push causes the TCPs to promptly forward and deliver data up to that point to the receiver. The exact push point might not be visible to the receiving user and the push function does not supply a record boundary marker.

- Reliability:

  The TCP must recover from data that is **damaged**, **lost**, **duplicated**, or **delivered out of order** by the internet communication system. This is achieved by assigning a **sequence number to each octet** transmitted, and requiring a **positive acknowledgment (ACK)** from the receiving TCP. If the ACK is not received within a **timeout** interval, the data is retransmitted. At the receiver, the sequence numbers are used to correctly **order segments** that may be received out of order and to **eliminate duplicates**. Damage is handled by adding a **checksum** to each segment transmitted, checking it at the receiver, and **discarding damaged segments**.

  As long as the TCPs continue to function properly and the internet system does not become completely partitioned, no transmission errors will affect the correct delivery of data. TCP recovers from internet communication system errors.

- Flow Control:

  TCP provides a means for the receiver to govern the amount of data sent by the sender. This is achieved by returning a **"window" with every ACK** indicating a range of acceptable sequence numbers beyond the last segment successfully received. The window indicates an allowed number of octets that the sender may transmit before receiving further permission.

- Multiplexing:

  To allow for many processes within a single Host to use TCP communication facilities simultaneously, the TCP provides a set of addresses or **ports** within each host. Concatenated with the network and host addresses from the internet communication layer, this forms a **socket**. A pair of sockets uniquely identifies each connection. That is, a socket may be simultaneously used in multiple connections.

  The binding of ports to processes is handled independently by each Host. However, it proves useful to attach frequently used processes (e.g., a "logger" or timesharing service) to fixed sockets which are made known to the public.  These services can then be accessed through the known addresses.  Establishing and learning the port addresses of other processes may involve more dynamic mechanisms.

- Connections:

  The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain **status** information for each **data stream**. **The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection**. Each connection is uniquely specified by a pair of sockets identifying its two sides.

  When two processes wish to communicate, their TCP's must first establish a connection (initialize the status information on each side).  When their communication is complete, the connection is terminated or closed to free the resources for other uses.

  Since connections must be established between unreliable hosts and over the unreliable internet communication system, a **handshake** mechanism with **clock-based sequence numbers** is used to avoid erroneous initialization of connections.

- Precedence and Security:

  The users of TCP may indicate the security and precedence of their communication. Provision is made for default values to be used when these features are not needed.

## 2. PHILOSOPHY

### 2.1. Elements of the Internetwork System

The internetwork environment consists of hosts connected to networks which are in turn interconnected via gateways. It is assumed here that the networks may be either local networks (e.g., the ETHERNET) or large networks (e.g., the ARPANET), but in any case are based on packet switching technology. The active agents that produce and consume messages are processes. Various levels of protocols in the networks, the gateways, and the hosts support an interprocess communication system that provides two-way data flow on logical connections between process ports.

The term **packet** is used generically here to mean the data of one transaction between a host and its network. The format of data blocks exchanged within the a network will generally not be of concern to us.

**Hosts** are computers attached to a network, and from the communication network's point of view, are the sources and destinations of packets. **Processes** are viewed as the active elements in host computers (in accordance with the fairly common definition of a process as a program in execution). Even terminals and files or other I/O devices are viewed as communicating with each other through the use of processes. Thus, all communication is viewed as inter-process communication.

Since a process may need to distinguish among several communication streams between itself and another process (or processes), we imagine that each process may have a number of ports through which it communicates with the ports of other processes.

### 2.2.  Model of Operation

Processes transmit data by calling on the TCP and passing buffers of data as arguments. The TCP packages the data from these buffers into segments and calls on the internet module to transmit each segment to the destination TCP. The receiving TCP places the data from a segment into the receiving user's buffer and notifies the receiving user. The TCPs include control information in the segments which they use to ensure reliable ordered data transmission.

The model of internet communication is that there is an **internet protocol module** associated with each TCP which provides an interface to the local network. This internet module packages TCP segments inside internet **datagrams** and routes these datagrams to a destination internet module or intermediate gateway. To transmit the datagram through the local network, it is embedded in a local network packet.

The packet switches may perform further packaging, fragmentation, or other operations to achieve the delivery of the local packet to the destination internet module.

At a gateway between networks, the internet datagram is "unwrapped" from its local packet and examined to determine through which network the internet datagram should travel next. The internet datagram is then "wrapped" in a local packet suitable to the next network and **routed** to the next gateway, or to the final destination.

A gateway is permitted to **break up an internet datagram** into smaller internet datagram fragments if this is necessary for transmission through the next network. To do this, the gateway produces a set of internet datagrams; each carrying a fragment. Fragments may be further broken into smaller fragments at subsequent gateways. The internet datagram fragment format is designed so that the destination internet module can reassemble fragments into internet datagrams.

A destination internet module unwraps the segment from the datagram  (after reassembling the datagram, if necessary) and passes it to the destination TCP.

This simple model of the operation glosses over many details. One important feature is the type of service. This provides information to the gateway (or internet module) to guide it in selecting the service parameters to be used in traversing the next network. Included in the type of service information is the precedence of the datagram.  Datagrams may also carry security information to permit host and gateways that operate in multilevel secure environments to properly segregate datagrams for security considerations.

### 2.3. The Host Environment

The TCP is assumed to be a module in an operating system. **The users access the TCP much like they would access the file system**. The TCP may call on other operating system functions, for example, to manage data structures. The actual interface to the network is assumed to be controlled by a device driver module. **The TCP does not call on the network device driver directly, but rather calls on the internet datagram protocol module which may in turn call on the device driver**.

The mechanisms of TCP do not preclude implementation of the TCP in a front-end processor. However, in such an implementation, a host-to-front-end protocol must provide the functionality to support the type of TCP-user interface described in this document.

### 2.4. Interfaces

The TCP/user interface provides for calls made by the user on the TCP to **OPEN** or **CLOSE** a connection, to **SEND** or **RECEIVE** data, or to obtain **STATUS** about a connection. These calls are like other calls from user programs on the operating system, for example, the calls to open, read from, and close a file.

The TCP/internet interface provides calls to send and receive datagrams addressed to TCP modules in hosts anywhere in the internet system.  These calls have parameters for passing the address, type of service, precedence, security, and other control information.

### 2.5. Relation to Other Protocols

The following diagram illustrates the place of the TCP in the protocol hierarchy:

       +------+ +-----+ +-----+       +-----+
       |Telnet| | FTP | |Voice|  ...  |     |  Application Level
       +------+ +-----+ +-----+       +-----+
             |   |         |             |
            +-----+     +-----+       +-----+
            | TCP |     | RTP |  ...  |     |  Host Level
            +-----+     +-----+       +-----+
               |           |             |
            +-------------------------------+
            |    Internet Protocol & ICMP   |  Gateway Level
            +-------------------------------+
                           |
              +---------------------------+
              |   Local Network Protocol  |    Network Level
              +---------------------------+

                         Protocol Relationships

                               Figure 2.

It is expected that the TCP will be able to support higher level protocols efficiently. It should be easy to interface higher level protocols like the ARPANET Telnet or AUTODIN II THP to the TCP.

### 2.6. Reliable Communication

A stream of data sent on a TCP connection is delivered reliably and in order at the destination.

Transmission is made reliable via the use of **sequence numbers** and acknowledgments. **Conceptually, each octet of data is assigned a sequence number**. The sequence number of the first octet of data in a segment is transmitted with that segment and is called the **segment sequence number**. Segments also carry an **acknowledgment number** which is the sequence number of the **next expected data octet of transmissions** in the reverse direction. When the TCP transmits a segment containing data, it puts a copy on a **retransmission queue** and starts a **timer**; when the **acknowledgment** for that data is received, the segment is deleted from the queue. If the acknowledgment is not received before the timer runs out, the segment is **retransmitted**.

An acknowledgment by TCP does not guarantee that the data has been delivered to the end user, but only that the receiving TCP has taken the responsibility to do so.

To govern the flow of data between TCPs, a **flow control** mechanism is employed. The receiving TCP reports a **"window"** to the sending TCP. This window specifies the **number of octets**, starting with the acknowledgment number, that the receiving TCP is currently prepared to receive.

### 2.7. Connection Establishment and Clearing

To identify the separate data streams that a TCP may handle, the TCP provides a port identifier. Since port identifiers are selected independently by each TCP they might not be unique. To provide for unique addresses within each TCP, we concatenate an internet address identifying the TCP with a **port identifier** to create a socket which will be unique throughout all networks connected together.

A connection is fully specified by the pair of sockets at the ends. A local socket may participate in many connections to different foreign sockets. A connection can be used to carry data in both directions, that is, it is "full duplex".

TCPs are free to associate ports with processes however they choose. However, several basic concepts are necessary in any implementation. There must be well-known sockets which the TCP associates only with the "appropriate" processes by some means. We envision that processes may "own" ports, and that processes can initiate connections only on the ports they own. (Means for implementing ownership is a local issue, but we envision a Request Port user command, or a method of uniquely allocating a group of ports to a given process, e.g., by associating the high order bits of a port name with a given process.)

A connection is specified in the **OPEN** call by the local port and foreign socket arguments. In return, the TCP supplies a (short) local connection name by which the user refers to the connection in subsequent calls. There are several things that must be remembered about a connection. To store this information we imagine that there is a data structure called a **Transmission Control Block (TCB)**.  One implementation strategy would have the local connection name be a pointer to the TCB for this connection. The **OPEN** call also specifies whether the connection establishment is to be actively pursued, or to be passively waited for.

A **passive OPEN** request means that the process wants to accept incoming connection requests rather than attempting to initiate a connection. Often the process requesting a passive OPEN will **accept a connection request** from any caller. In this case a foreign socket of all zeros is used to denote an unspecified socket. **Unspecified foreign sockets** are allowed only on passive OPENs.

A service process that wished to provide services for unknown other processes would issue a passive OPEN request with an unspecified foreign socket. Then a connection could be made with any process that requested a connection to this local socket. It would help if this local socket were known to be associated with this service.

Well-known sockets are a convenient mechanism for a priori associating a socket address with a standard service. For instance, the "Telnet-Server" process is permanently assigned to a particular socket, and other sockets are reserved for File Transfer, Remote Job Entry, Text Generator, Echoer, and Sink processes (the last three being for test purposes). A socket address might be reserved for access to a "Look-Up" service which would return the specific socket at which a newly created service would be provided. The concept of a well-known socket is part of the TCP specification, but the assignment of sockets to services is outside this specification.  (See [4].)

Processes can issue passive OPENs and wait for matching active OPENs from other processes and be informed by the TCP when connections have been established. **Two processes which issue active OPENs to each other at the same time will be correctly connected**. This flexibility is critical for the support of distributed computing in which components act asynchronously with respect to each other.

There are two principal cases for matching the sockets in the local passive OPENs and an foreign active OPENs. In the first case, the local passive OPENs has fully specified the foreign socket. In this case, the match must be exact. In the second case, the local passive OPENs has left the foreign socket unspecified. In this case, any foreign socket is acceptable as long as the local sockets match. Other possibilities include partially restricted matches.

If there are several pending passive OPENs (recorded in TCBs) with the same local socket, an foreign active OPEN will be matched to a TCB with the specific foreign socket in the foreign active OPEN, if such a TCB exists, before selecting a TCB with an unspecified foreign socket.

The procedures to establish connections utilize the synchronize (SYN) control flag and involves an exchange of three messages. This exchange has been termed a **three-way hand shake** [3].

A connection is initiated by the rendezvous of an arriving segment containing a SYN and a waiting TCB entry each created by a user OPEN command. The matching of local and foreign sockets determines when a connection has been initiated. The connection becomes **"established"** when sequence numbers have been synchronized in both directions.

The clearing of a connection also involves the exchange of segments, in this case carrying the FIN control flag.

### 2.8. Data Communication

The data that flows on a connection may be thought of as a stream of octets. The sending user indicates in each **SEND** call whether the data in that call (and any preceeding calls) should be immediately pushed through to the receiving user by the setting of the **PUSH flag**.

A sending TCP is allowed to collect data from the sending user and to send that data in segments at its own convenience, **until the push function is signaled**, then it must send all unsent data. When a receiving TCP sees the PUSH flag, it must not wait for more data from the sending TCP before passing the data to the receiving process.

There is no necessary relationship between push functions and segment boundaries. The data in any particular segment may be the result of a single SEND call, in whole or part, or of multiple SEND calls.

The purpose of push function and the PUSH flag is to push data through from the sending user to the receiving user. It does not provide a record service.

There is a coupling between the push function and the use of buffers of data that cross the TCP/user interface. Each time a PUSH flag is associated with data placed into the receiving user's buffer, the buffer is returned to the user for processing even if the buffer is not filled. If data arrives that fills the user's buffer before a PUSH is seen, the data is passed to the user in buffer size units.

TCP also provides a means to communicate to the receiver of data that at some point further along in the data stream than the receiver is currently reading there is urgent data.  TCP does not attempt to define what the user specifically does upon being notified of pending urgent data, but the general notion is that the receiving process will take action to process the urgent data quickly.

### 2.9. Precedence and Security

The TCP makes use of the internet protocol type of service field and security option to provide precedence and security on a per connection basis to TCP users. Not all TCP modules will necessarily function in a multilevel secure environment; some may be limited to unclassified use only, and others may operate at only one security level and compartment. Consequently, some TCP implementations and services to users may be limited to a subset of the multilevel secure case.

TCP modules which operate in a multilevel secure environment must properly mark outgoing segments with the security, compartment, and precedence. Such TCP modules must also provide to their users or higher level protocols such as Telnet or THP an interface to allow them to specify the desired security level, compartment, and precedence of connections.

### 2.10. Robustness Principle

TCP implementations will follow a general principle of robustness: be conservative in what you do, be liberal in what you accept from others.

## 3. FUNCTIONAL SPECIFICATION

### 3.1. Header Format

**TCP segments** are sent as **internet datagrams**. The Internet Protocol header carries several information fields, including the source and destination host addresses [2].  A TCP header follows the internet header, supplying information specific to the TCP protocol.  This division allows for the existence of host level protocols other than TCP.

TCP Header Format

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Source Port          |       Destination Port        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                        Sequence Number                        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                    Acknowledgment Number                      |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |  Data |           |U|A|P|R|S|F|                               |
       | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
       |       |           |G|K|H|T|N|N|                               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           Checksum            |         Urgent Pointer        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                    Options                    |    Padding    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                             data                              |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
                                TCP Header Format
    
              Note that one tick mark represents one bit position.
    
                               Figure 3.

- Source Port:  16 bits

  The source port number.

- Destination Port:  16 bits

  The destination port number.

- Sequence Number:  32 bits

  The sequence number of the first data octet in this segment (except when SYN is present). If SYN is present the sequence number is the **initial sequence number (ISN)** and the first data octet is ISN+1.

- Acknowledgment Number:  32 bits

  If the ACK control bit is set this field contains the value of the next sequence number the sender of the segment is expecting to receive. Once a connection is established this is **always sent**.

- Data Offset:  4 bits

  The number of 32 bit words in the TCP Header. This indicates where the data begins. **The TCP header (even one including options) is an integral number of 32 bits long**.

- Reserved:  6 bits

  Reserved for future use. Must be zero.

- Control Bits:  6 bits (from left to right):

  - URG: Urgent Pointer field significant
  - ACK: Acknowledgment field significant
  - PSH: Push Function
  - RST: Reset the connection
  - SYN: Synchronize sequence numbers
  - FIN: No more data from sender

- Window:  16 bits

  The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.

- Checksum:  16 bits

  The checksum field is the 16 bit one's complement of the one's complement sum of all 16 bit words in the header and text. If a segment contains an odd number of header and text octets to be checksummed, the last octet is padded on the right with zeros to form a 16 bit word for checksum purposes. The pad is not transmitted as part of the segment. **While computing the checksum, the checksum field itself is replaced with zeros**.

  The checksum also covers a 96 bit **pseudo header conceptually prefixed to the TCP header**. This pseudo header contains the **Source Address**, the **Destination Address**, the **Protocol**, and **TCP length**. This gives the TCP protection against **misrouted segments**. This information is **carried in the Internet Protocol** and is transferred across the TCP/Network interface in the arguments or results of calls by the TCP on the IP.

                     +--------+--------+--------+--------+
                     |           Source Address          |
                     +--------+--------+--------+--------+
                     |         Destination Address       |
                     +--------+--------+--------+--------+
                     |  zero  |  PTCL  |    TCP Length   |
                     +--------+--------+--------+--------+

  The **TCP Length** is the TCP header length plus the data length in octets (this is **not an explicitly transmitted quantity**, but is computed), and it does not count the 12 octets of the pseudo header.

- Urgent Pointer:  16 bits

  This field communicates the current value of the urgent pointer as a positive offset from the sequence number in this segment. The urgent pointer points to the sequence number of the octet following the urgent data. This field is **only be interpreted in segments with the URG control bit set**.

- Options:  variable

  Options may occupy space at the end of the TCP header and are a multiple of 8 bits in length. All options are included in the checksum. An option **may begin on any octet boundary**. There are two cases for the format of an option:

  - Case 1:  A single octet of **option-kind**.

  - Case 2:  An octet of **option-kind**, an octet of **option-length**, and the actual **option-data** octets.

    The option-length counts the two octets of option-kind and
    option-length as well as the option-data octets.

  Note that the list of options may be shorter than the data offset field might imply.  The content of the header beyond the End-of-Option option must be **header padding** (i.e., zero).

  A TCP must implement all options.

  Currently defined options include (kind indicated in octal):

      Kind     Length    Meaning
      ----     ------    -------
       0         -       End of option list.
       1         -       No-Operation.
       2         4       Maximum Segment Size.

  Specific Option Definitions

  - End of Option List

        +--------+
        |00000000|
        +--------+
         Kind=0

    This option code indicates the end of the option list. This might not coincide with the end of the TCP header according to the Data Offset field. This is used at the end of all options, not the end of each option, and need only be used if the end of the options would not otherwise coincide with the end of the TCP header.

  - No-Operation

        +--------+
        |00000001|
        +--------+
         Kind=1

    This option code may be used **between options**, for example, to align the beginning of a subsequent option on a word boundary. There is **no guarantee** that senders will use this option, so receivers must be prepared to process options even if they do not begin on a word boundary.

  - Maximum Segment Size

        +--------+--------+---------+--------+
        |00000010|00000100|   max seg size   |
        +--------+--------+---------+--------+
         Kind=2   Length=4

    Maximum Segment Size Option Data:  16 bits

    If this option is present, then it communicates the maximum receive segment size at the TCP which sends this segment. This field **must only be sent in the initial connection request** (i.e., in segments with the SYN control bit set).  If this option is not used, any segment size is allowed.

- Padding:  variable

  The TCP header padding is used to ensure that the TCP header ends and data begins on a 32 bit boundary.  The padding is composed of zeros.

### 3.2. Terminology

Before we can discuss very much about the operation of the TCP we need to introduce some detailed terminology. The maintenance of a TCP connection requires the remembering of several variables. We conceive of these variables being stored in a connection record called a **Transmission Control Block or TCB**. Among the variables stored in the TCB are the **local and remote socket numbers**, the **security and precedence** of the connection, pointers to the user's **send and receive buffers**, pointers to the **retransmit queue** and to the **current segment**. In addition several variables relating to the send and receive **sequence numbers** are stored in the TCB.

- Send Sequence Variables

  `SND.UNA` - send unacknowledged

  `SND.NXT` - send next

  `SND.WND` - send window

  `SND.UP`  - send urgent pointer

  `SND.WL1` - segment sequence number used for last window update

  `SND.WL2` - segment acknowledgment number used for last window update

  `ISS`     - initial send sequence number

- Receive Sequence Variables

  `RCV.NXT` - receive next

  `RCV.WND` - receive window

  `RCV.UP`  - receive urgent pointer

  `IRS`     - initial receive sequence number

The following diagrams may help to relate some of these variables to the sequence space.

Send Sequence Space

                   1         2          3          4
              ----------|----------|----------|----------
                     SND.UNA    SND.NXT    SND.UNA
                                          +SND.WND

        1 - old sequence numbers which have been acknowledged
        2 - sequence numbers of unacknowledged data
        3 - sequence numbers allowed for new data transmission
        4 - future sequence numbers which are not yet allowed

                          Send Sequence Space

                               Figure 4.

The send window is the portion of the sequence space labeled 3 in figure 4.

Receive Sequence Space

                       1          2          3
                   ----------|----------|----------
                          RCV.NXT    RCV.NXT
                                    +RCV.WND

        1 - old sequence numbers which have been acknowledged
        2 - sequence numbers allowed for new reception
        3 - future sequence numbers which are not yet allowed

                         Receive Sequence Space

                               Figure 5.

The receive window is the portion of the sequence space labeled 2 in figure 5.

There are also some variables used frequently in the discussion that take their values from the fields of the current segment.

- Current Segment Variables

  `SEG.SEQ` - segment sequence number

  `SEG.ACK` - segment acknowledgment number

  `SEG.LEN` - segment length

  `SEG.WND` - segment window

  `SEG.UP`  - segment urgent pointer

  `SEG.PRC` - segment precedence value

A connection progresses through a series of states during its lifetime. The states are: `LISTEN`, `SYN-SENT`, `SYN-RECEIVED`, `ESTABLISHED`, `FIN-WAIT-1`, `FIN-WAIT-2`, `CLOSE-WAIT`, `CLOSING`, `LAST-ACK`, `TIME-WAIT`, and the fictional state `CLOSED`. `CLOSED` is fictional because it represents the state when there is no TCB, and therefore, no connection. Briefly the meanings of the states are:

- `LISTEN` - represents waiting for a **connection request** from any remote TCP and port.

- `SYN-SENT` - represents waiting for a matching **connection request** after having sent a **connection request**.

- `SYN-RECEIVED` - represents waiting for a confirming **connection request acknowledgment** after having both received and sent a **connection request**.

- `ESTABLISHED` - represents an open connection, data received can be delivered to the user. The **normal state** for the data transfer phase of the connection.

- `FIN-WAIT-1` - represents waiting for a **connection termination request** from the remote TCP, or an acknowledgment of the connection termination request previously sent.

- `FIN-WAIT-2` - represents waiting for a **connection termination request** from the remote TCP.

- `CLOSE-WAIT` - represents waiting for a **connection termination request** from the local user.

- `CLOSING` - represents waiting for a **connection termination request** acknowledgment from the remote TCP.

- `LAST-ACK` - represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP (which includes an acknowledgment of its connection termination request).

- `TIME-WAIT` - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.

- `CLOSED` - represents no connection state at all.

A TCP connection progresses from one state to another in response to events. The events are the **user calls**, `OPEN`, `SEND`, `RECEIVE`, `CLOSE`, `ABORT`, and `STATUS`; the **incoming segments**, particularly those containing the `SYN`, `ACK`, `RST` and `FIN` flags; and **timeouts**.

The state diagram in figure 6 illustrates only state changes, together with the causing events and resulting actions, but addresses **neither error conditions nor actions which are not connected with state changes**. In a later section, more detail is offered with respect to the reaction of the TCP to events.

NOTE BENE: this diagram is only a summary and must not be taken as the total specification.

                                  +---------+ ---------\      active OPEN
                                  |  CLOSED |            \    -----------
                                  +---------+<---------\   \   create TCB
                                    |     ^              \   \  snd SYN
                       passive OPEN |     |   CLOSE        \   \
                       ------------ |     | ----------       \   \
                        create TCB  |     | delete TCB         \   \
                                    V     |                      \   \
                                  +---------+            CLOSE    |    \
                                  |  LISTEN |          ---------- |     |
                                  +---------+          delete TCB |     |
                       rcv SYN      |     |     SEND              |     |
                      -----------   |     |    -------            |     V
     +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
     |         |<-----------------           ------------------>|         |
     |   SYN   |                    rcv SYN                     |   SYN   |
     |   RCVD  |<-----------------------------------------------|   SENT  |
     |         |                    snd ACK                     |         |
     |         |------------------           -------------------|         |
     +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
       |           --------------   |     |   -----------
       |                  x         |     |     snd ACK
       |                            V     V
       |  CLOSE                   +---------+
       | -------                  |  ESTAB  |
       | snd FIN                  +---------+
       |                   CLOSE    |     |    rcv FIN
       V                  -------   |     |    -------
     +---------+          snd FIN  /       \   snd ACK          +---------+
     |  FIN    |<-----------------           ------------------>|  CLOSE  |
     | WAIT-1  |------------------                              |   WAIT  |
     +---------+          rcv FIN  \                            +---------+
       | rcv ACK of FIN   -------   |                            CLOSE  |
       | --------------   snd ACK   |                           ------- |
       V        x                   V                           snd FIN V
     +---------+                  +---------+                   +---------+
     |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|
     +---------+                  +---------+                   +---------+
       |                rcv ACK of FIN |                 rcv ACK of FIN |
       |  rcv FIN       -------------- |    Timeout=2MSL -------------- |
       |  -------              x       V    ------------        x       V
        \ snd ACK                 +---------+delete TCB         +---------+
         ------------------------>|TIME WAIT|------------------>| CLOSED  |
                                  +---------+                   +---------+
    
                          TCP Connection State Diagram
                                   Figure 6.













TODO TCP rfc-793